package edu.towson.cis.cosc455.rob.project1.implementation;

import java.util.ArrayList;
import java.util.Stack;

import MarkdownTokenDefinitions.HtmlDefinitions;
import MarkdownTokenDefinitions.TokenDefinitions.Type;


/**
 * @author Robert
 *
 */

public class SemanticAnalyzer {
	/**Holds the tokens generated by the lexical analyzer */
	public static ArrayList<Token> tokenBin;
	/**Holds the index of the token currently in use*/
	public static int tokenBinIndex;
	/**Turns debugging information from the compiler on or off*/
	public static boolean verboseOutput;
	
	/**
	 * Constructor for the semantic analyzer
	 */
	public SemanticAnalyzer(){
		tokenBin = Compiler.tokenBin;
		tokenBinIndex = 0;
		verboseOutput = Compiler.verboseOutput;
		
	}
	
	/**
	 * Iterates thru the tokenBin and returns a string containing properly formatted HTML
	 * @return a properly formatted HTML document
	 */
	
	public String translateToHtml(){
		/**String containing the compiled HTML */
		String htmlFile = "";
		/**Flag indicating whether the first head tag (of the pair of head tags) has been encountered*/
		boolean headBegin = false;
		/**Flag indicating whether the first italics tag (of the pair of italics tags) has been encountered*/
		boolean italicsBegin = false;
		/**Flag indicating whether the first bold tag (of the pair of bold tags) has been encountered*/
		boolean boldBegin = false;
		/**Flag indicating whether a new list element (list element not followed by a previous list element)has been encountered*/
		boolean newListHasBegun = false; 
		/**Flag indicating whether a list element not followed by another list element)has been encountered*/
		boolean listHasEnded = false;


		tokenBinIndex = 0;
		
		if(verboseOutput){
			
			System.out.println("Sem: translateToHtml()(): Starting html translation");
		}
		
		Token t = tokenBin.get(tokenBinIndex );
		while(tokenBinIndex  < tokenBin.size() - 1){
			switch(t.tokenType){
			case TEXT:
				htmlFile += t.content;
				break;
			case WHITESPACE:
				htmlFile += t.content;
				break;
			case DOCB: 
				htmlFile += getOpenTag(HtmlDefinitions.HTML_DOC);
				break;
			case TITLEB:
				htmlFile += getOpenTag(HtmlDefinitions.HTML_TITLE);
				break;
			case PARAB: 
				htmlFile += getOpenTag(HtmlDefinitions.HTML_PARA);
				break;
			case LISTITEMB:
				if(!newListHasBegun){
					newListHasBegun = true;
					htmlFile += getOpenTag(HtmlDefinitions.HTML_LIST);
					htmlFile += getOpenTag(HtmlDefinitions.HTML_LISTITEM);
				}
				else{
					htmlFile += getOpenTag(HtmlDefinitions.HTML_LISTITEM);
				}
				break;
				//special case
			case LINKB: 
				htmlFile = convertLinkNodeToHtmlLink(htmlFile);
				break;
			case AUDIO:  
				htmlFile = convertAudioNodeToHtml(htmlFile);
				break;
			case VIDEO:  
				htmlFile = convertVideoNodeToHtml(htmlFile);
			
		
			case NEWLINE:  
				htmlFile += getOpenTag(HtmlDefinitions.HTML_NEWLINE);
				break;
			case DOCE:  
				htmlFile += getCloseTag(HtmlDefinitions.HTML_DOC);
				break;
			case TITLEE:  
				htmlFile += getCloseTag(HtmlDefinitions.HTML_TITLE);
				break;
			case PARAE: 
				htmlFile += getCloseTag(HtmlDefinitions.HTML_PARA);
				break;
			case LISTITEME:  
				htmlFile += getCloseTag(HtmlDefinitions.HTML_LISTITEM);
				if(!isAnotherListItemAhead()){
					htmlFile += getCloseTag(HtmlDefinitions.HTML_LIST);
					newListHasBegun = false;
					listHasEnded = true;
				}
				
				
				break;
			case HEAD:  
				if(headBegin){
					htmlFile += getCloseTag(HtmlDefinitions.HTML_HEAD);
					headBegin = false;
				}
				else{
					headBegin = true;
					htmlFile += getOpenTag(HtmlDefinitions.HTML_HEAD);
					break;
				}
				break;
			case BOLD:  
				if(boldBegin){
					htmlFile += getCloseTag(HtmlDefinitions.HTML_BOLD);
					boldBegin = false;
				}
				else{
					htmlFile += getOpenTag(HtmlDefinitions.HTML_BOLD);
					boldBegin = true;
				}
				break;
			case ITALICS:  
				if(italicsBegin){
					htmlFile += getCloseTag(HtmlDefinitions.HTML_ITALICS);
					italicsBegin = false;
				}
				else{
					htmlFile += getOpenTag(HtmlDefinitions.HTML_ITALICS);
					italicsBegin = true;
				}
				break;

			case ADDRESSB: 
			case ADDRESSE:
			case LINKE: 
			default:
				if(verboseOutput){
					System.out.println("Oops, html switch came across a token containing " + t.content);
				}
				break;
			}
			if(verboseOutput){
				System.out.println("Sem: translateToHtml(): current token is " + t.tokenType);
				System.out.println("Sem: translateToHtml(): html is" + htmlFile);
			}
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex );
			
		}
		return htmlFile;
	}
	
	/**
	 * Takes a sequence of tokens for a video link and converts into a properly formatted
	 * HTML iframe element
	 * @param htmlFile
	 * @return A correctly formatted HTML iframe segment
	 */
	private String convertVideoNodeToHtml(String htmlFile) {
		Token t;
		
		htmlFile += HtmlDefinitions.HTML_BRACKET_L + HtmlDefinitions.HTML_VIDEO+ " " +
				 HtmlDefinitions.HTML_SRC + "=\"";
		
		tokenBinIndex += 2; //skip past '%('
		t = tokenBin.get(tokenBinIndex);
		while(t.tokenType != Type.ADDRESSE){
			htmlFile += t.content;
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex);
		}
		
		return htmlFile += "\"" + HtmlDefinitions.HTML_BRACKET_CLOSE + HtmlDefinitions.HTML_BRACKET_R;
	}
	/**
	 * Takes a sequence of tokens for an audio link and converts into a properly formatted
	 * HTML audio element
	 * @param htmlFile
	 * @return A correctly formatted  HTML audio string
	 */
	private String convertAudioNodeToHtml(String htmlFile) {
		// TODO Auto-generated method stub
		
		Token t;
		
		htmlFile += HtmlDefinitions.HTML_BRACKET_L + HtmlDefinitions.HTML_AUDIO + " " +
				 HtmlDefinitions.HTML_AUDIO_CONTROLS + HtmlDefinitions.HTML_BRACKET_R + "\n";
		htmlFile += HtmlDefinitions.HTML_BRACKET_L + HtmlDefinitions.HTML_SOURCE + " " + HtmlDefinitions.HTML_SRC + "=\"";
				;
		tokenBinIndex += 2; //skip past '@('
		t = tokenBin.get(tokenBinIndex);
		while(t.tokenType != Type.ADDRESSE){
			htmlFile += t.content;
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex);
		}
		
		return htmlFile += "\"" + HtmlDefinitions.HTML_BRACKET_R + "\n" + getCloseTag(HtmlDefinitions.HTML_AUDIO);
		
	}
	/**
	 * Takes a sequence of tokens for an HTML link and converts into a properly formatted
	 * HTML link element with link text and link address
	 * @param htmlFile 
	 * @return A correctly formatted HTML link string
	 */
	private String convertLinkNodeToHtmlLink(String htmlFile) {
		// TODO Auto-generated method stubs
		String linkText = "", linkAddress = "";
		Token t;
		
		tokenBinIndex++;
		t = tokenBin.get(tokenBinIndex);
		while(t.tokenType != Type.LINKE){
			linkText += t.content;
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex);
		}
		//skip LINK END Token
		tokenBinIndex++;
		t = tokenBin.get(tokenBinIndex);
		//Grab address of link, ignore whitespace between ) [
		if(t.tokenType == Type.WHITESPACE){
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex);
		}
		if(t.tokenType == Type.ADDRESSB){
			tokenBinIndex++;
			t = tokenBin.get(tokenBinIndex);
			while(t.tokenType != Type.ADDRESSE){
				linkAddress += t.content;
				tokenBinIndex++;
				t = tokenBin.get(tokenBinIndex);
			}
		}
		//completed scan of link address
		//convert to html
		if(verboseOutput){
			System.out.println("Sem: convertLinkNodeToHtmlLink(): link address " + linkAddress);
			System.out.println("Sem: convertLinkNodeToHtmlLink(): link text " + linkText);
		}
		 return htmlFile += getOpenTag(HtmlDefinitions.HTML_LINK + " " + HtmlDefinitions.HTML_HREF + "=\"" + linkAddress + "\"") + 
				linkText + getCloseTag(HtmlDefinitions.HTML_LINK);
		
		
	}

	/**
	 * Looks ahead in the tokenBin to see if another list item 
	 * immediately follows the current list item
	 * @return True or False, depending on whether another list item 
	 * immediately follows
	 */
	private boolean isAnotherListItemAhead() {
		// TODO Auto-generated method stub
		int localIndex = tokenBinIndex;
		Token t = tokenBin.get(++localIndex);
		
		while(t.tokenType == Type.WHITESPACE){
			if(verboseOutput){
				System.out.println("Sem: isAnotherListItemAhead(): during comparison, current token is " + t.tokenType + " , local index is " + localIndex);
			}
			localIndex++;
			t = tokenBin.get(localIndex);
		}
		if(verboseOutput){
			System.out.println("Sem: isAnotherListItemAhead(): during comparison, current token is " + t.tokenType);
			System.out.println("Sem: isAnotherListItemAhead(): Comparing " + t.tokenType + " with " + Type.LISTITEMB);
		}
		return t.tokenType == (Type.LISTITEMB);
	}

	/**
	 * This method generates an HTML closing tag 
	 * @param htmlTag HTML element
	 * @return complete HTML element inside a closing tag
	 */
	private String getCloseTag(String htmlTag) {
		// TODO Auto-generated method stub
		return HtmlDefinitions.HTML_BRACKET_L + HtmlDefinitions.HTML_BRACKET_CLOSE + htmlTag + HtmlDefinitions.HTML_BRACKET_R;
	}
	/**
	 * This method generates an HTML opening tag 
	 * @param htmlTag HTML element 
	 * @return complete HTML element inside a opening tag
	 */
	private String getOpenTag(String htmlTag) {
		return HtmlDefinitions.HTML_BRACKET_L + htmlTag + HtmlDefinitions.HTML_BRACKET_R;
		
	}

	/**
	 * This method iterates through the markdown tokens and replaces a variable
	 * with its value
	 * @throws CompilerException if variable definition was not found
	 */
	public void resolveVariables() throws CompilerException{
		
		boolean headBegin = false, italicsBegin = false, boldBegin = false; 
		for(tokenBinIndex = 0; tokenBinIndex < tokenBin.size(); tokenBinIndex++){
			Token t = tokenBin.get(tokenBinIndex);
			
			switch(t.tokenType){
			case TEXT:
			case WHITESPACE:
			case DOCB:  
			case TITLEB:  
			case PARAB:  
			case DEFB:  
			case LISTITEMB:  
			case LINKB:  
			case AUDIO:  
			case VIDEO:  
			case ADDRESSB: 
			case NEWLINE:  
			case DEFUSEE:  
			case EQSIGN: 
				if(verboseOutput){System.out.println("Sem: going to next token");}
				
				break;
			case USEB:
				if(verboseOutput){System.out.println("Sem: " + Type.USEB +" found, calling variableHunter()");}
				variableHunter();
				
				break;
			case DOCE:  
				if(verboseOutput){System.out.println("Sem: " + Type.DOCE +" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.DOCB);
				break;
			case TITLEE:  
				if(verboseOutput){System.out.println("Sem: " + Type.TITLEE +" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.TITLEB);
				break;
			case PARAE: 
				if(verboseOutput){System.out.println("Sem: " + Type.PARAE +" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.PARAB);
				break;
			case LISTITEME:  
				if(verboseOutput){System.out.println("Sem: " + Type.LISTITEME+" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.LISTITEMB);
				break;
			case ADDRESSE:  
				if(verboseOutput){System.out.println("Sem: " + Type.ADDRESSE+" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.ADDRESSB);
				break;
			case LINKE:  
				if(verboseOutput){System.out.println("Sem: " + Type.LINKE+" found, calling variableDefinitionDestroyer()");}
				variableDefinitionDestroyer(Type.LINKB);
				break;
			
			case HEAD:  
				if(headBegin){
					if(verboseOutput){System.out.println("Sem: " + Type.HEAD +" found, calling variableDefinitionDestroyer()");}
				
					variableDefinitionDestroyer(Type.HEAD);
					headBegin = false;
				}
				else{
					headBegin = true;
				}
				break;
			case BOLD:  
				if(boldBegin){
					if(verboseOutput){System.out.println("Sem: " + Type.BOLD +" found, calling variableDefinitionDestroyer()");}
				
					variableDefinitionDestroyer(Type.BOLD);
					boldBegin = false;
				}
				else{
					boldBegin = true;
				}
				break;
			case ITALICS:  
				if(italicsBegin){
					if(verboseOutput){System.out.println("Sem: " + Type.ITALICS +" found, calling variableDefinitionDestroyer()");}
				
					variableDefinitionDestroyer(Type.ITALICS);
					italicsBegin = false;
				}
				else{
					italicsBegin = true;
				}
				break;		
			}
	
		}
			
		
	}
	
	/**
	 * This method iterates thru the tokenBin until it finds a token of a 
	 * particualr type and returns its index
	 * @param t The type of token that the method is looking for
	 * @param currentIndex the index from which the method will start it's search
	 * @return the index of the next token of Type t
	 */
	public int getNextIndexOfType(Type t, int currentIndex){
		while(tokenBin.get(currentIndex).tokenType != t){
			currentIndex++;
		}
		
		return currentIndex;
	}
	
	/**
	 * This method is used to get the name of a variable by 
	 * returning its content 
	 * @param t a variable token
	 * @return a string containing the variable's name
	 */
	public String getVariableName (Token t){
		return t.content;
	}
	/**
	 * This method iterates backwards thru the tokenBin looking for a variable definition 
	 * @param t a variable token
	 * @return a string containing the variable's value
	 * @throws CompilerException if variable definition was not found
	 */
	public String findVariableDefinition(String varName, int varUseIndex) throws CompilerException{
		int currentIndex = varUseIndex, tempIndex = varUseIndex;
	
		
		while(currentIndex > 0){
			currentIndex--;
			Token t = tokenBin.get(currentIndex);
			
			if(verboseOutput){
				System.out.println("Sem: findVariableDefinition(): current token is " + t.tokenType + ", content is " + t.content);
			}

			if(t.tokenType == Type.DEFB){
				tempIndex = currentIndex;
				
				if(verboseOutput){
					System.out.println("Sem: findVariableDefinition(): " + Type.DEFB + " Found");
				}
				
				while(t.tokenType != Type.TEXT){
					t = tokenBin.get(currentIndex++);
				}
				
				if(t.content.equals(varName)){
					if(verboseOutput){
						System.out.println("Sem: findVariableDefinition(): Varname " + varName + " Found");
					}
					t = tokenBin.get(++currentIndex);
					while(t.tokenType != Type.EQSIGN){
						t = tokenBin.get(++currentIndex);
					}
					while(t.tokenType != Type.TEXT){
						t = tokenBin.get(++currentIndex);
					}
					if(verboseOutput){
						System.out.println("Sem: findVariableDefinition(): var def is " + t.content );
					}
					return t.content;
					
				}
				else{
					if(verboseOutput){
						System.out.println("Sem: findVariableDefinition(): searching for " + varName + " found " + t.content); 
					}
					currentIndex = tempIndex - 1;
					t = tokenBin.get(currentIndex);
				}
			}
			
			
			
			
			
		}
		throw new CompilerException(getSemanticErrorMessage(varName)); 
	}
	
	/**
	 * This method returns a meaningful error message
	 * @param varName he name of the variable
	 * @return the string
	 */
	private String getSemanticErrorMessage(String varName) {
		String errorMessage = "Semantic Error: variable : \""+ varName + "\" is undefined";
		
		return "\n" + errorMessage + "\n";
	}

	/**
	 * This method adds the defined value of the variable at the location where there variable was used
	 * @param index index of the tokenBin at which the variable was found
	 * @param content the string to be inserted
	 */
	public void replaceVarNameWithValue(int index, String content){

		tokenBin.add(index, new Token(Type.TEXT, content));
		System.out.println("Sem: replaceVarNameWithValue(): after replacing var name with def :" );
		System.out.println(printTokenStream());
		
	}
	
	/**
	 * This method removes a variable usage statement from the tokenBin
	 * @param varUseIndex the index at which the variable usage begins
	 */
	public void snipVarUsage(int varUseIndex){
		String before = "", after = "";

		
		before = printTokenStream();
		
		
		Token t = tokenBin.get(varUseIndex);
		
		while(t.tokenType != Type.DEFUSEE){
			if(verboseOutput){
				printTokenStream();
			}
			tokenBin.remove(varUseIndex);
			t = tokenBin.get(varUseIndex);
		}
		tokenBin.remove(varUseIndex);
		if(verboseOutput){
			System.out.println("Sem: snipVarUsage(): removing " + t.tokenType + ": " + t.content + " at index " + varUseIndex);
			System.out.println("Sem: snipVarUsage(): Tokens after removing var usage");
			after = printTokenStream();	
			printBeforeAndAfter(before,after);
		}
	}
	
	/**
	 * This method prints two different strings, useful for debugging translations
	 * @param before String before changes occurred
	 * @param after String after changes occurred
	 */
	private void printBeforeAndAfter(String before, String after) {
		// TODO Auto-generated method stub
		System.out.println("Before: " + before);
		System.out.println("After: " + after);
	}
	
	/**
	 * this method prints out the contents of all tokens in the tokenBin
	 * @return the string
	 */
	private String printTokenStream() {
		// TODO Auto-generated method stub
		String tokens = "";
		for(Token x : tokenBin){
			tokens += x.content;
		}
		tokens += "\n";
		return tokens;
	}

	/**
	 * This method organizes the removal of a variable expression and replacing it with its defintion
	 * @throws CompilerException
	 */
	public void variableHunter() throws CompilerException{
		int varUseIndex = 0;
		String varName, varContent;
		
		String before = printTokenStream();
		
		if(verboseOutput){
			System.out.println("Sem: variableHunter(): $USE  at index " + tokenBinIndex);
		}	
		varUseIndex = getNextIndexOfType(Type.TEXT, tokenBinIndex);
		varName = getVariableName((Token)tokenBin.get(varUseIndex));
		if(verboseOutput){
			System.out.println("Sem: variableHunter(): varName is " + varName + " varIndex is " + varUseIndex);
		}
		
		varContent = findVariableDefinition(varName,varUseIndex);
		
		if(verboseOutput){
			System.out.println("Sem: variableHunter(): varContent is " + varContent);
			System.out.println("Sem: variableHunter(): calling snipVarUsage()" );
			String after = printTokenStream();
			printBeforeAndAfter(before, after);
		}
		snipVarUsage(tokenBinIndex);
		replaceVarNameWithValue(tokenBinIndex, varContent);
		
	}
	/**
	 * This method searches back through the tokenBin, 
	 * deleting any variable defintions that it finds
	 * @param terminalType
	 */
	public void variableDefinitionDestroyer(Type terminalType){
		int currentIndex = tokenBinIndex;
		int count = 0;
		Token t;

		do{
			currentIndex--;
			
			t = tokenBin.get(currentIndex);
			
			if(verboseOutput){
				System.out.println("Sem: variableDefinitionDestroyer(): current token is " + t.tokenType + " hunting for " + terminalType);
				System.out.println("Sem: variableDefinitionDestroyer(): currentIndex + " + currentIndex);
			}
			
			if(t.tokenType == Type.DEFUSEE){
				
				
				while(t.tokenType != Type.DEFB){
					currentIndex--;
					count++;
					t = tokenBin.get(currentIndex);
					if(verboseOutput){
						System.out.println("Sem: variableDefinitionDestroyer():  current token is " + t.content);
					}
				}
				count++;
				for(int i = 0; i < count; i++){
					t = tokenBin.get(currentIndex);
					if(verboseOutput){
						System.out.println("Sem: variableDefinitionDestroyer(): removing " + t.tokenType + ": " + t.content + " at index " + currentIndex);
						System.out.println(printTokenStream());
					}
					tokenBin.remove(currentIndex);
				}
				printTokenStream();
			}
			
			if(verboseOutput && t.tokenType == terminalType){
				System.out.println("Sem: variableDefinitionDestroyer(): current token is " + t.tokenType + " hunting for " + terminalType);
				System.out.println("I'll be exiting now");
			}
			
			
		}while(t.tokenType != terminalType);
		if(verboseOutput && t.tokenType == terminalType){
			System.out.println("Sem: variableDefinitionDestroyer(): current token is " + t.tokenType + " hunting for " + terminalType);
			System.out.println("Elvis has left the building");
			System.out.println(printTokenStream());
		}
		

		}
	
}
	

